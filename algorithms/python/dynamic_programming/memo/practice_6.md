# 最長増加部分列 
## 問題の整理

- n 本の木が横一列に並んでいる。
- 木 i の高さは a_i [cm]。
- 木をいくつか伐採して、残った木が左から順に単調増加になるようにしたい。
- できるだけ多くの木を残すには、**最長増加部分列 (LIS)** を求める問題に言い換えられる。

---

## DPで考える

### 部分問題

- **dp[k]** を「木 k を最後にした増加部分列の長さ」とする。
- dp[1..k-1] が求まっているとして、dp[k] は次のように決まる：

```
dp[k] = 1                 # 木 k のみからなる部分列
for i = 1 to k-1:
    if a[i] < a[k]:
        dp[k] = max(dp[k], dp[i] + 1)
```

- 意味：木 i を最後にした部分列に木 k を追加できれば、長さ dp[i]+1 に更新する。
- 最終的に答えは dp[1..n] の最大値。

---

## Pythonでの実装例

```python
n = int(input())
a = [int(input()) for _ in range(n)]

dp = [1] * n  # 最低でも各木単独で長さ1

for i in range(n):
    for j in range(i):
        if a[j] < a[i]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))
```

---

## ポイント

1. DP 配列 dp[i] は「木 i を最後にした増加部分列の長さ」。
2. 木 j (j < i) の高さが a[j] < a[i] なら、dp[i] を dp[j]+1 で更新。
3. 最終的に dp の最大値が **残せる木の最大数**。
4. 時間計算量は O(n^2) で、n ≤ 5000 の制約でも十分。

---
