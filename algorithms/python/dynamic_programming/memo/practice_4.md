# りんごの最小購入金額（2個・5個バージョン）

## 問題
八百屋にて、りんご2個が `a` 円、りんご5個が `b` 円で売られている。  

**n 個のりんごを手に入れるために必要な最小金額**を求める。  
買った結果、`n+1` 個以上になってもよい。

---

## 考え方

1. `dp[i]` を **ちょうど i 個のりんごを買うのに必要な最小金額** とする。  
   - 作れない場合は `INF` のような大きな値で初期化する

2. 最後に買うパターンは：
   - i-2 個まで買って2個買う → `dp[i-2] + a`
   - i-5 個まで買って5個買う → `dp[i-5] + b`

3. 漸化式：
   ```
   dp[i] = min(dp[i-2] + a, dp[i-5] + b)
   ```
   - i >= 2, i >= 5 の場合のみ更新
   - dp[i] が初期値 INF の場合は「作れない」

4. 初期条件：
   ```
   dp[0] = 0  # 0個のりんごを買う金額は0
   ```

5. n 個以上買う最小金額：
   ```
   min(dp[n], dp[n+1], dp[n+2], dp[n+3], dp[n+4])
   ```
   - 余裕を持って n+4 個まで計算しておくと安全

---

## 模範解答コード（Python）

```python
n, a, b = map(int, input().split())

INF = float('inf')
dp = [INF] * (n + 5)  # n+4まで余裕を持つ
dp[0] = 0

for i in range(1, n + 5):
    if i >= 2:
        dp[i] = min(dp[i], dp[i - 2] + a)
    if i >= 5:
        dp[i] = min(dp[i], dp[i - 5] + b)

# n個以上買う最小金額
print(min(dp[n:]))
```

---

## ポイント

- 「ちょうど作れない個数」がある場合は **n個以上買う最小値** を考える  
- dp[i] は **i個ちょうど買う最小金額**  
- 余裕を持って n+4 個くらいまで計算しておくと安全  
- 別の配列を作らなくても `min(dp[n:])` で答えを得られる  
- このパターンは「作れない組み合わせがある組み合わせDP」の応用

---
