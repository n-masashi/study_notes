# 最長背の順区間の長さ (Longest Non-Decreasing Subarray)

## 問題の整理

- n 人が横一列に並んでいる。
- 人 i の身長は a_i [cm]。
- 区間 [l, r] が **背の順** とは、全ての l ≤ i < r に対して a_i ≤ a_{i+1} が成り立つもの。
- そのような区間の長さは r-l+1。
- 求めたいのは **最長の背の順区間の長さ**。

---

## DPで考える

### 部分問題

- **dp[i]** を「人 i が右端となる背の順区間の長さ」とする。
- つまり dp[i] は **人 i を含む連続区間のうち背の順の最長**。

---

### 漸化式の考え方

- 人 i-1 を右端とする背の順区間の長さは dp[i-1]。
- もし a[i-1] ≤ a[i] なら、区間に人 i をくっつけて **長さ dp[i-1]+1** の区間が作れる。
- 逆に a[i-1] > a[i] なら、人 i が右端の区間は **長さ 1** しかない。
- よって漸化式は：

```
dp[1] <- 1
for i = 2 to n
    if a[i-1] <= a[i] then
        dp[i] <- dp[i-1]+1
    else
        dp[i] <- 1
```

- 最終的な答えは dp[1..n] の最大値。

---

## Pythonでの実装例

```python
n = int(input())
a = [int(input()) for _ in range(n)]

dp = [0] * n
dp[0] = 1

for i in range(1, n):
    if a[i-1] <= a[i]:
        dp[i] = dp[i-1] + 1
    else:
        dp[i] = 1

print(max(dp))
```

---

## ポイント

1. DP の配列 dp[i] は「右端が i の最長背の順区間の長さ」。
2. 前の人と比べて背が低くなったら、区間をリセットして長さ 1。
3. 前の人と比べて背が高いか同じなら、区間を伸ばして長さ +1。
4. 最後に dp の最大値を取ることで **最長区間の長さ** を求められる。
5. 時間計算量は O(n) で、n ≤ 200,000 の制約でも十分。

---
