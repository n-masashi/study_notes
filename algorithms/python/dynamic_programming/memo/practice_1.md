# 階段を上る方法の数（DP練習）

## 問題
整数 `n` が与えられる。  
階段を上るのに「1歩で1段」または「1歩で2段」上ることができるとき、  
**n 段の階段を上る方法は何通りあるか**を求める。

---

## 考え方

1. **小さい段数を考えてみる**
   - 1段の階段: 1通り（1段上る）
   - 2段の階段: 2通り（1+1 か 2）
   - 3段の階段:  
     - 1段＋（2段の上り方2通り）  
     - 2段＋（1段の上り方1通り）  
     → 合計 3通り

2. **規則を見つける**
   - `dp[n]` = n段の上り方の数
   - 最後の一歩が「1段」の場合 → `dp[n-1]` 通り  
   - 最後の一歩が「2段」の場合 → `dp[n-2]` 通り  
   - よって次の式が成り立つ：
     ```
     dp[n] = dp[n-1] + dp[n-2]
     ```

3. **初期条件**
   - `dp[0] = 1`（階段を登らずに「何もしない」方法）
   - `dp[1] = 1`（1段だけ登る）

---

## 模範解答コード（Python）

```python
n = int(input())

dp = [1] * (n + 1)   # 最初から [1, 1, 1, ...] にしておく

for i in range(2, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]

print(dp[n])
```

---

## 別解（場合分けスタイル）

```python
n = int(input())

dp = [0] * (n + 1)
dp[0] = 1

for i in range(1, n + 1):
    if i >= 1:
        dp[i] += dp[i - 1]
    if i >= 2:
        dp[i] += dp[i - 2]

print(dp[n])
```

---

## ポイントまとめ
- **部分問題に分ける**のがDPの考え方。
- 「n段目にたどり着くには `n-1` 段から来るか、`n-2` 段から来るしかない」。
- 模範解答は最初から `dp` を `[1] * (n+1)` で用意してシンプルに書いている。
- 別解は「場合分けを残した形」になっており、より丁寧にDPの流れを理解しやすい。

---

## 違和感を感じたところ（整理）

「2段目の上り方は `[1+1]` と `[2]` の2通りなのに、  
`dp[2] = dp[1] + dp[0]` と書くと `1 + 1 = 2` になっていて、  
`dp[0]`（＝何もしない1通り）を足しているのが不思議に感じた

→ この違和感の正体は **`dp[0]` を “何もしない” とだけ考えてしまったこと**。

実際には：
- `dp[0] = 1` は「0段目にいる状態が1通り」  
- そこから「2段まとめて登る」動きを組み合わせることで、 `[2]` というパターンが生まれる  

だから `dp[2] = dp[1] + dp[0]` の内訳は：
- `dp[1]` 部分 → `[1,1]`  
- `dp[0]` 部分 → `[2]`

これでちょうど2通りが数えられていることになる。

---

## 一般化のヒント
- 「1段 or 2段」なら `dp[n] = dp[n-1] + dp[n-2]`
- 「1,2,3段」なら `dp[n] = dp[n-1] + dp[n-2] + dp[n-3]`
- 「偶数段だけ」なら `dp[n] = dp[n-2]`

つまり、**ルールに応じて漸化式を変える**のがDPの基本。

---
