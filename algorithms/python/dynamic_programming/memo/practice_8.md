# 部分和の通り数を数える（順不同・各おもりは高々1回）

## 問題の要約
- 重さ `a_1..a_n` の **おもりをいくつか選ぶ**（同じおもりは2回使えない）。
- 合計が **ちょうど `x`** になる **方法の数** を数える。
- **重さが同じでも別のおもりは区別**して数える（= インデックスが違えば別物）。
- 答えは `MOD = 1_000_000_007` で割った余り。

---

## 方針（DP）
- `dp[j]`：**いままで見たおもり**を使って「**和が j**」になる方法の数。
- 初期値：`dp[0] = 1`（何も選ばない1通り）。
- おもり `a[i]` を1つずつ処理し、**後ろから**更新：
  - `for j in range(x, a[i]-1, -1): dp[j] += dp[j - a[i]]`
  - これで **同じおもりを2回使うことを防止**（前から回すと同じおもりを再利用してしまう）。

### なぜ「後ろから」？
- `dp[j]` を前から更新すると、**その場で増えた `dp[j]` をまた使って**「同じおもりをもう1回足す」ことになる（重複使用）。
- 後ろからなら、参照する `dp[j - a[i]]` は **前のおもりまでの結果**のままなので安全。

---

## 計算量
- 時間：`O(n * x)`、空間：`O(x)`（1次元DP）。

---

## 実装（Python）

```python
MOD = 1_000_000_007

# 入力
n, x = map(int, input().split())
a = [int(input()) for _ in range(n)]

# dp[j] = 和が j になる「方法の数」
dp = [0] * (x + 1)
dp[0] = 1  # 何も選ばない 1 通り

for w in a:  # 各おもり（同じ重さでも別個体として処理）
    for j in range(x, w - 1, -1):  # 後ろから（重複使用を防ぐ）
        dp[j] = (dp[j] + dp[j - w]) % MOD

print(dp[x] % MOD)
```

---

## ミニ例で確認（入力例）
```
n = 5, x = 10
a = [7, 3, 4, 3, 2]
```
- 通り数は `3`。例：
  - 7 + 3（1つ目の3）
  - 7 + 3（2つ目の3）
  - 3 + 4 + 3（3,4,3 の3つ）
  - ※ 3 同士は **別個体** なので 7+3 は 2 通りとして数える。

---
