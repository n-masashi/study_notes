# 部分和問題

## 問題の整理

- n 個のおもりがあり、おもり i の重さは a_i。
- 何個かのおもりを選んで **重さの合計が x** になるかを判定する。
- 同じおもりを複数回選ぶことはできない。

---

## DPで考える

### 部分問題

- **dp[k][x]** を「おもり 1 〜 k を使って重さの合計を x にできるかどうか」とする。
- おもり k を使う場合と使わない場合で場合分けできる：

```
dp[k][x] = dp[k-1][x] or dp[k-1][x - a[k]]
```

- 意味：
  - dp[k-1][x] → おもり k を使わずに x を作れる
  - dp[k-1][x - a[k]] → おもり k を使って x を作れる

---

### 配列を1次元で効率化

- dp[k][x] は dp[k-1][x] と dp[k-1][x-a[k]] のみで求まるため、1次元配列で計算できる。
- **注意**：ループは x から a_i へ **減らす方向** に回す。

```
dp[0..x] = False
dp[0] = True  # 重さ0は何も選ばず可能

for i in 1..n:  # おもり i
    for j in x..a[i] (減らす):
        if dp[j - a[i]] == True:
            dp[j] = True

# 結果判定
if dp[x]:
    print("yes")
else:
    print("no")
```

- **減らす方向** にループする理由：
  - 1つのおもりを複数回使うことを避けるため。
  - もし増やす方向に回すと、同じおもりを2回以上使うことになり誤った判定になる。

---

## 例

```
n = 5, x = 19
a = [7, 18, 5, 4, 8]
```

ステップ：

1. dp[0] = True, dp[1..19] = False
2. i=1, a[1]=7
   - j=19..7 → dp[7] = True
3. i=2, a[2]=18
   - j=19..18 → dp[18] = True
4. i=3, a[3]=5
   - j=19..5 → dp[12] = True (7+5), dp[5] = True
5. i=4, a[4]=4
   - j=19..4 → dp[16] = True (12+4), dp[9] = True (5+4), dp[11] = True (7+4)
6. i=5, a[5]=8
   - j=19..8 → dp[19] = True (11+8)

結果：dp[19] = True → yes

---

# 解答例

```python
# 入力
n, x = map(int, input().split())　# n: おもりの個数, x: 作りたい重さの合計
a = [int(input()) for _ in range(n)]　# 各おもりの重さをリストに格納

# DP 配列の初期化
dp = [False] * (x + 1)
dp[0] = True  # 重さ0は何も選ばず作れる

# DP 本体
for i in range(n):
    for j in range(x, a[i] - 1, -1):  # 後ろから回すことで同じおもりを2回使わない
        # j-a[i] の重さが作れるなら、今のおもりを使えば j の重さも作れる
        if dp[j - a[i]]:
            dp[j] = True

# 結果出力
if dp[x]:
    print("yes")
else:
    print("no")
```

## ポイント
  - dp[j] は「重さ j を作れるか」を表す。
  - ループは x → a[i] の順で回すことで、同じおもりを2回使うことを防ぐ。
  - 計算量 O(n*x)。
